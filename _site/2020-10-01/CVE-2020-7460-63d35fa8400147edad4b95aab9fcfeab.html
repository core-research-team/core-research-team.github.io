<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="soS2al0KuMZmiyPzu87KFbqGSn0K9edQ8EkWp_m35n0" />
  

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>CVE-2020-7460 | Core-Research-Team</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="CVE-2020-7460" />
<meta name="author" content="wwwlk" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="라온화이트햇 핵심연구팀 조진호" />
<meta property="og:description" content="라온화이트햇 핵심연구팀 조진호" />
<link rel="canonical" href="http://202.182.127.225:4000/2020-10-01/CVE-2020-7460-63d35fa8400147edad4b95aab9fcfeab" />
<meta property="og:url" content="http://202.182.127.225:4000/2020-10-01/CVE-2020-7460-63d35fa8400147edad4b95aab9fcfeab" />
<meta property="og:site_name" content="Core-Research-Team" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-01T00:00:00+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"CVE-2020-7460","dateModified":"2020-10-01T00:00:00+00:00","datePublished":"2020-10-01T00:00:00+00:00","author":{"@type":"Person","name":"wwwlk"},"url":"http://202.182.127.225:4000/2020-10-01/CVE-2020-7460-63d35fa8400147edad4b95aab9fcfeab","mainEntityOfPage":{"@type":"WebPage","@id":"http://202.182.127.225:4000/2020-10-01/CVE-2020-7460-63d35fa8400147edad4b95aab9fcfeab"},"description":"라온화이트햇 핵심연구팀 조진호","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.ico">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://202.182.127.225:4000/feed.xml" title="Core-Research-Team" />

  <!-- Google Analytics-->
  
 
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">RAON - Core Research Team</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post"> 
   <h1 class="post-title">CVE-2020-7460</h1>
   <div class="post-line"></div>

   
      
         
            <span class="tag"><center><i>CVE</i></center></span>
         
      
   
   
   <ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#vulnerability">Vulnerability</a></li>
  <li><a href="#trigger">Trigger</a></li>
  <li><a href="#primitive">Primitive</a></li>
  <li><a href="#controlling-rip">Controlling RIP</a></li>
  <li><a href="#exploit">Exploit</a></li>
</ul>
   
   <p>라온화이트햇 핵심연구팀 조진호</p>

<h1 id="summary">Summary</h1>

<p>freebsd kernel TOCTOU 버그로 아래 ZDI문서를 정리한 것이다. 취약점 패치 로그는 <code class="highlighter-rouge">3846ff841491a990212681f423ac8e26c39032b9</code>이며 parent는 <code class="highlighter-rouge">b14963930ff962f492bcb8705785ea1e481615a2</code>이다.</p>

<p><a href="https://www.thezdi.com/blog/2020/9/1/cve-2020-7460-freebsd-kernel-privilege-escalation">https://www.thezdi.com/blog/2020/9/1/cve-2020-7460-freebsd-kernel-privilege-escalation</a></p>

<h1 id="vulnerability">Vulnerability</h1>

<p>취약점은 <code class="highlighter-rouge">freebsd/sys/compat/freebsd32/freebsd32_misc.c</code> 파일의 <code class="highlighter-rouge">freebsd32_copyin_control</code>라는 함수에 있다. 이 함수는 두개의 반복문으로 이루어져 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// </span>
<span class="c1">// ----------------------- FIRST LOOP ----------------------- </span>
<span class="c1">// </span>
<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msglen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msglen</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">error</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span> 
    <span class="n">msglen</span> <span class="o">=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">msglen</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span> 
    <span class="n">idx</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span> 
    <span class="n">msglen</span> <span class="o">+=</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span> <span class="o">-</span> 
        <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span> 
    <span class="n">len</span> <span class="o">+=</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span> 
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MCLBYTES</span><span class="p">)</span> 
    <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>

<span class="c1">// </span>
<span class="c1">// ALLOCATE KERNEL MEMORY </span>
<span class="c1">// </span>
<span class="n">m</span> <span class="o">=</span> <span class="n">m_get</span><span class="p">(</span><span class="n">M_WAITOK</span><span class="p">,</span> <span class="n">MT_CONTROL</span><span class="p">);</span> 
<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MLEN</span><span class="p">)</span> 
    <span class="n">MCLGET</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M_WAITOK</span><span class="p">);</span> 
<span class="n">m</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</code></pre></div></div>

<p>첫번째 루프로 <code class="highlighter-rouge">copyin</code>은 <code class="highlighter-rouge">copy_from_user</code>라고 생각하면 된다. 파라미터 생긴거도 똑같이 생겼다. 따라서 코드는 유저의 입력을 받는데, 이 입력은 특정 메시지의 길이다.</p>

<p><img src="/assets/2010ho.png" alt="/assets/2010ho.png" /></p>

<p>이 길이가 바운드를 넘지 않는지 체크를 하고 메모리 할당을 하고 난 뒤 길이를 넣는다. 여러 크기의 cmsg를 할당하면 위와 같은 그림의 메모리 상태가 된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// </span>
<span class="c1">// ----------------------- SECOND LOOP ----------------------- </span>
<span class="c1">// </span>
<span class="n">md</span> <span class="o">=</span> <span class="n">mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span> 
<span class="k">while</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> 
        <span class="k">break</span><span class="p">;</span> 
    <span class="n">msglen</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u_int</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span><span class="p">;</span> 
    <span class="n">msglen</span> <span class="o">=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>

    <span class="cm">/* Modify the message length to account for alignment. */</span> 
    <span class="o">*</span><span class="p">(</span><span class="n">u_int</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">=</span> <span class="n">msglen</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">))</span> <span class="o">-</span> 
        <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>

    <span class="n">md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span> 
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span> 
    <span class="n">buflen</span> <span class="o">-=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>

    <span class="n">msglen</span> <span class="o">-=</span> <span class="n">FREEBSD32_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">error</span> <span class="o">=</span> <span class="n">copyin</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">msglen</span><span class="p">);</span> <span class="c1">// &lt;&lt;-------- OVERFLOW </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> 
            <span class="k">break</span><span class="p">;</span> 
        <span class="n">md</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">md</span> <span class="o">+</span> <span class="n">CMSG_ALIGN</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span> 
        <span class="n">buf</span> <span class="o">+=</span> <span class="n">msglen</span><span class="p">;</span> 
        <span class="n">buflen</span> <span class="o">-=</span> <span class="n">msglen</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">m_free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="k">else</span>
		<span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</code></pre></div></div>

<p>그리고 <code class="highlighter-rouge">mtod</code>는 위에서 할당한 <code class="highlighter-rouge">mbuf</code>를 포인터로 바꾸는건데 이렇게 변환하고 난 <code class="highlighter-rouge">md</code>는 포인터로 사용할 수 있다. <code class="highlighter-rouge">buflen</code>은 함수에 파라미터로 들어온 컨트롤 메시지(cmsg)배열의 전체 크기이다. 따라서 남은 컨트롤 메시지가 있다면 <code class="highlighter-rouge">copyin</code>으로 포인터로 바꿨던 <code class="highlighter-rouge">mbuf</code>에 있는 값들을 읽어 위에서 적어놨던 <code class="highlighter-rouge">len</code>과 비교하려 에러가 난다면 에러를 반환한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">cmsghdr</span> <span class="p">{</span>
    <span class="n">socklen_t</span> <span class="n">cmsg_len</span><span class="p">;</span>       <span class="cm">/* data byte count, including hdr */</span>
    <span class="kt">int</span>       <span class="n">cmsg_level</span><span class="p">;</span>     <span class="cm">/* originating protocol */</span>
    <span class="kt">int</span>       <span class="n">cmsg_type</span><span class="p">;</span>      <span class="cm">/* protocol-specific type */</span> 
    <span class="cm">/* u_char cmsg_data[]; */</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>이 구조체는 컨트롤 메시지 헤더다.</p>

<p><img src="/assets/2010ho1.png" alt="/assets/2010ho1.png" /></p>

<p>에러가 아닌 정상적으로 작동을 해서 두번째 루프에서 길이를 변경시켰다고 한다면 이런 메모리 상태가 된다. 이 사이에서 취약점은 발생할 수 있다.</p>

<p><img src="/assets/2010ho2.png" alt="/assets/2010ho2.png" /></p>

<p>첫번째 루프에서 <code class="highlighter-rouge">m-&gt;len = len;</code>으로 박아버리고 나서 두번째 루프에서 검사를 하고 에러를 하고 마지막에 free를 해버리기 때문에 힙 오버가 발생할 수 있다.</p>

<h1 id="trigger">Trigger</h1>

<p>트리거는 <code class="highlighter-rouge">sendmsg</code>를 이용하는데 이는 힙 스프레이에도 많이 사용하는거다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">sendmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">msghdr</span> <span class="p">{</span> 
    <span class="kt">void</span>         <span class="o">*</span><span class="n">msg_name</span><span class="p">;</span>       <span class="cm">/* optional address */</span> 
    <span class="n">socklen_t</span>     <span class="n">msg_namelen</span><span class="p">;</span>    <span class="cm">/* size of address */</span> 
    <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">msg_iov</span><span class="p">;</span>        <span class="cm">/* scatter/gather array */</span> 
    <span class="kt">int</span>           <span class="n">msg_iovlen</span><span class="p">;</span>     <span class="cm">/* # elements in msg_iov */</span> 
    <span class="kt">void</span>         <span class="o">*</span><span class="n">msg_control</span><span class="p">;</span>    <span class="cm">/* ancillary data, see below */</span> 
    <span class="n">socklen_t</span>     <span class="n">msg_controllen</span><span class="p">;</span> <span class="cm">/* ancillary data buffer len */</span> 
    <span class="kt">int</span>           <span class="n">msg_flags</span><span class="p">;</span>      <span class="cm">/* flags on received message */</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>여기서 <code class="highlighter-rouge">msg_control</code>가 사용자 버퍼가 시작되는 곳인데 이 주변에 <code class="highlighter-rouge">cmsghdr</code>이 위치한다고 한다. 트리거 하기 위해서는 다음 3가지를 해야한다고 한다.</p>

<ul>
  <li>연속된 <code class="highlighter-rouge">cmsghdr</code>생성</li>
  <li>한 스레드로 <code class="highlighter-rouge">sendmsg()</code> 호출</li>
  <li>다른 스레드로 <code class="highlighter-rouge">cmsg_len</code>을 증가</li>
</ul>

<p>이를 이용하면 몇초 내에 커널패닉을 발생시킬 수 있다.</p>

<h1 id="primitive">Primitive</h1>

<p>레이스를 할 때 여러 스레드가 돌아가는데 언제까지 돌가야하는지 알 수 없다. 저대로 돌리기만 하면 멈추지 않는 오버플로우가 되어버린다. 이를 해결하기 위한 방법은로 unmap page를 이용했다.</p>

<p><img src="/assets/2010ho3.png" alt="/assets/2010ho3.png" /></p>

<p>위에서 <code class="highlighter-rouge">copyin</code>으로 데이터를 읽는데 unmapped page를 만나면 에러를 출력하므로 이를 이용해 <code class="highlighter-rouge">EFAULT</code>가 나오면 우리가 원하는 데이터를 덮고 그 뒤 unmapped page를 만났구나 라는 것을 알 수 있다.</p>

<h1 id="controlling-rip">Controlling RIP</h1>

<p>먼저 할당되는 <code class="highlighter-rouge">mbuf</code>구조체를 보고 가자. <code class="highlighter-rouge">mbuf</code>는 freebsd에서 할당한 메모리를 관리하는 기본 유닛 단위라고  보면 된다. 네트워크 패킷이나 소켓 데이터들이 이거로 할당된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* description of external storage mapped into mbuf, valid if M_EXT set */</span>
<span class="k">struct</span> <span class="n">m_ext</span> <span class="p">{</span>
	<span class="n">caddr_t</span>	<span class="n">ext_buf</span><span class="p">;</span>		<span class="cm">/* start of buffer */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">ext_free</span><span class="p">)();</span>		<span class="cm">/* free routine if not the usual */</span>
	<span class="n">u_int</span>	<span class="n">ext_size</span><span class="p">;</span>		<span class="cm">/* size of buffer, for ext_free */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mbuf</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">m_hdr</span> <span class="n">m_hdr</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span>	<span class="n">pkthdr</span> <span class="n">MH_pkthdr</span><span class="p">;</span>	<span class="cm">/* M_PKTHDR set */</span>
			<span class="k">union</span> <span class="p">{</span>
				<span class="k">struct</span>	<span class="n">m_ext</span> <span class="n">MH_ext</span><span class="p">;</span>	<span class="cm">/* M_EXT set */</span>
				<span class="kt">char</span>	<span class="n">MH_databuf</span><span class="p">[</span><span class="n">MHLEN</span><span class="p">];</span>
			<span class="p">}</span> <span class="n">MH_dat</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">MH</span><span class="p">;</span>
		<span class="kt">char</span>	<span class="n">M_databuf</span><span class="p">[</span><span class="n">MLEN</span><span class="p">];</span>		<span class="cm">/* !M_PKTHDR, !M_EXT */</span>
	<span class="p">}</span> <span class="n">M_dat</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>여기서 볼건 <code class="highlighter-rouge">ext_free</code>라는 함수 포인터인데 특이하게 구조체가 해제 할 루틴을 구조체 내에 정의해놨다. 저걸 바꿀 수 있으면 rip를 돌릴 수 있다.</p>

<p>먼저 <code class="highlighter-rouge">mbuf</code>를 할당해 스프레이를 해야한다. 이 건 udp 클라/서버를 만들어서 <code class="highlighter-rouge">sendto()</code>를 호출하여 만들 수 있다. <code class="highlighter-rouge">sendto()</code>내에 있는 <code class="highlighter-rouge">PushMbuf()</code> 가 새로운 <code class="highlighter-rouge">mbuf</code>들을 할당한다. 그리고 <code class="highlighter-rouge">recvfrom</code>으로 받을 때 <code class="highlighter-rouge">ext_free</code>에 포인터가 있다면 들렸다가 해제한다. 이 과정에서는 <code class="highlighter-rouge">PushMbuf()</code>와 반대로 <code class="highlighter-rouge">PopMbuf()</code>가 호출된다. 정리하자면 아래와 같다.</p>

<ul>
  <li><code class="highlighter-rouge">PushMbuf()</code>로 힙에 채워넣기</li>
  <li><code class="highlighter-rouge">PopMbuf()</code>로 넣은 <code class="highlighter-rouge">mbuf</code>중 절반정도 해제한다.</li>
  <li>레이스 취약점인 힙오버로 해제되지 않은 <code class="highlighter-rouge">mbuf</code>의 <code class="highlighter-rouge">ext_free</code>를 덮는다.</li>
  <li>트리거 되었을 때 <code class="highlighter-rouge">PopMbuf()</code>로 해제한다.</li>
</ul>

<h1 id="exploit">Exploit</h1>

<p>이제 rip제어까지 완료했다. rip제어에 성공했을 때 <code class="highlighter-rouge">free</code>에 들어가게 되니 첫번째 파라미터인 rdi는 <code class="highlighter-rouge">mbuf</code>의 위치가 된다. 이 익스에서는 rop를 이용해 트리거했고, cr4를 조작하여 SMEP, SMAP를 풀고 kaslr은 안걸려있는 환경에서 진행했다.</p>

<p>exploit code: <a href="https://github.com/thezdi/PoC/blob/master/CVE-2020-7460/CVE-2020-7460.c">https://github.com/thezdi/PoC/blob/master/CVE-2020-7460/CVE-2020-7460.c</a></p>

<p><a href="https://www.notion.so/CCE-2020-Maetdol-b4c7281aba6941d1be886968cc639079">CCE 2020 - Maetdol</a></p>

   </div>
</div>


  <!-- Start disqus 
<script src="/assets/js/disqusLoader.js" /></script>
<div id="disqus_thread"><h3>Discussion and feedback</h3></div>
<div class="disqus"></div>
<script>
    disqusLoader('.disqus', {
        scriptUrl: 'https://jekyll-tale.disqus.com/embed.js'
    });
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
End disqus -->


<div class="pagination">
  
   <a href="/2020-10-01/Cheat-Engine-DBVM-8b5aa7dc092c4dd2b81b7d4696266309" class="left arrow">&#8592;</a>
  
  
   <a href="/2020-10-01/CCE-2020-Maetdol_" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>
    </main>

    <!--footer>
  <span>
    &copy; <time datetime="2021-03-08 07:19:49 +0000">2021</time> Core-Research-Team. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer-->

  </body>
</html>
